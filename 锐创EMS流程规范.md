本文先是整体介绍软件开发过程中的关键节点 和 可能涉及的文档，对其中的若干关键点进程阐述，然后对关键的几个技术点进一步说明。

# 1. 文档规范

在本章节，按照软件开发的流程，对关键节点输出的文档进行一一描述，对最关键的2个环节 **需求分析** 和 **概要设计** 重点着墨。

## 1.1 需求分析

在系统工程及软件工程中，需求分析指的是在建立一个新的或改变一个现存的系统或产品时，确定新系统的目的、范围、定义和功能时所要做的所有工作。需求分析是软件工程中的一个关键过程。在这个过程中，系统分析员和软件工程师确定顾客的需要。只有在确定了这些需要后他们才能够分析和寻求新系统的解决方法。

在软件工程的历史中，很长时间里人们一直认为需求分析是整个软件工程中最简单的一个步骤，但在过去十年中越来越多的人认识到它是整个过程中最关键的一个过程。假如在需求分析时，分析者们未能正确地认识到顾客的需要的话，那么最后的软件实际上不可能达到顾客的需要，或者软体无法在规定的时间里完工。

需求分析的产物主要有3类：用户故事、原型、用例。

### 1.1.1 用户故事

用户故事（英语：User story）是软件开发和项目管理中的常用术语。主旨是以日常语言或商务用语撰写句子，是一段简单的功能表述。以客户或使用者的观点撰写下有价值的功能、引导、框架来与使用者进行互动，进而推动工作进程。可以被认为是一种规格文件，但更精确而言，它代表客户的需求与方向。以该用户故事来反应对象在组织内的其工作职责、范围、需要进行的任务等。用户故事在敏捷开发方法中用来定义系统需要提供的功能和实现需求管理。

**一般采用以下句式：**

> 作为一名xxxx用户，我希望有一个xxx功能，帮助我完成xxx事情，这样能带来xxx好处。

### 1.1.2 原型

原型模拟最终软件的屏幕显示，这样用户可以看到最终软件将是什么样，而实际上在这些屏幕显示的背后还一切都空着呢。这样顾客可以在系统还没有建立之前就做出设计决定。当原型首次被使用的时候它们的效果被视为非常惊人。引入原型往往提高顾客与开发者之间的信息交换。原型的屏幕显示后来往往很少被改变，因此可以大大地降低费用。

目前，一般使用`Axure`画原型图，其交付的成果也称为`RP`图。

### 1.1.3 用例

用例（英语：use case），或译使用案例、用况，是软件工程或系统工程中对系统如何反应外界请求的描述，是一种通过用户的使用场景来获取需求的技术。每个用例提供了一个或多个场景，该场景说明了系统是如何和最终用户或其它系统互动，也就是谁可以用系统做什么，从而获得一个明确的业务目标。编写用例时要避免使用技术术语，而应该用最终用户或者领域专家的语言。

用例图并不是画成了图形的用例。用例图包含一组用例。每一用例用椭圆表示，放置在矩形框中；矩形框表示整个系统。矩形框外画如图所示的小人，表示参与者。参与者不一定是人，可以是其他软件、硬件等等。某一参与者与某一用例用线连起来，表示该参与者和该用例有交互。

下面是一个用例图：

![image-20191222214408866](锐创EMS流程规范.assets/image-20191222214408866.png)

## 1.2 概要设计

概要设计是指由个人或团队（设计师或是设计团队）为需求对象所撰写的专案开发文件，它将专案中包含的任何产品或工作内容（功能性与美感）、时程以及预算等具体地描绘出交付内容与规模。设计概要可以运用在许多不同范畴的专案上，像是建筑、室内设计以及工业设计等。设计概要同时也可以用于评估成品，以及确保专案能够被有效追踪并在预算内完成。每间公司对于设计概要的使用程度不尽相同，不过业界对于设计过程中的责任归属的日益重视，因此很多人认为它能派上用场。设计概要的内容经常随着专案的演进而调整，通常它是在专案初期阶段由客户以及设计师所签核。

概要设计有3个要点：问题陈述、设计目标、设计方案。

很多概要设计，都将设计方案作为主要内容，忽视了 **问题陈述** 和 **设计目标**，这是非常不可取的，**问题陈述**再一次重申要解决的问题，**设计目标**定义了设计要达到的要求，没有这两部分，无法评估 **设计方案** 。

### 1.2.1 问题陈述

**问题陈述** 是以「软件开发方」的视角，对要解决的问题，用「开发团队」内部的语言，进行一项项的明确描述，是

「设计方案」要解决的问题全集，也是「测试用例」的重要参考。

### 1.2.2 设计目标

**设计目标**  是对该软件的「合理预期」，希望达到的若干具体指标，可以是「功能性的」，也可以是「技术指标」。

### 1.2.3 设计方案

**设计方案** 是概要设计的重要组成部分，有时会提供多种方案，并对每种方案的优劣进行评估，最终选择一种方案，并说明原因。

**设计方案** 主要包含2部分：模型设计 和 流程设计。

#### 1.2.3.1 模型设计

**模型设计** 是方案的核心，是解决方案的 **数据结构** ，是对方案中静态内容的 **抽象**，是描述每一个 **业务对象** 的骨架，有每一个主要 业务对象 的**定义与描述**，也有这些对象之间 **关联关系**。

**模型设计** 可以有多种输出形式，如：ER图、PDM 或 普通表格。

#### 1.2.3.2 流程设计

**流程设计** 是对「模型对象」的操作，是解决方案中的 **算法**，是对方案中动态内容的 **抽象**，使「模型」中的「对象」能够串的起来，更具体的表示如何解决问题。

**流程设计** 可以使用各种流程图 或者 清晰的文字描述来说明。

## 1.3 详细设计

**详细设计** 是对 **概要设计**的细化，提供更细粒度的内容，如 定义好的表结构、前后台接口、关键算法的详细步骤 等 。

## 1.4 测试用例

软件工程中的测试用例是一组条件或变量，测试者根据它来确定应用软件或软件系统是否正确工作。确定软件程序或系统是否通过测试的方法叫做测试准则。

## 1.5 测试报告

在对系统整体测试完之后，给出的一份全面的测试报告。

## 1.6 部署手册

在交付软件时，与「软件安装包」同时提供的，有2份资料：部署手册 和 用户手册。

部署手册指导用户将软件 安装到自己服务器的过程，一般部署是由乙方提供的服务，但「部署手册」是不可少的一份文档。

## 1.7 用户手册

**用户手册** 是用户在使用软件时的参考手册，由产品经理提供，不缀述。

# 2. 编码质量

**编码质量** 是软件质量的重要保证，很多公司不遗余力的抓编码质量，并将总结的经验分享出来，我们可以借鉴。

## 2.1 阿里巴巴Java开发手册

该手册以 Java 开发者为中心视角，划分为 **编程规约**、**异常日志**、**单元测试**、**安全规约**、**MySQL数据库**、**工程结构**、**设计规约**七个维度，再根据内容特征，细分成若干二级子目录。 另外，依据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。在延伸信息中， “说明”对规约做了适当扩展和解释;“正例”提倡什么样的编码和实现方式;“反例”说明需要 提防的雷区，以及真实的错误案例。

不只是文档，该项目还提供了配套的工具「IDE插件」，在日常编码的同时，对可能存在问题的代码进行提示。

**项目地址：**https://github.com/alibaba/p3c

## 2.2 Findbugs

FindBugs是由Bill Pugh和David Hovemeyer创建的开源程序，用来查找Java代码中的程序错误。它使用静态分析来识别Java程序中上百种不同类型的潜在错误。潜在错误可分为四个等级：恐怖的（scariest）、吓人的（scary）、令人困扰的（troubling）和值得关注的（of concern），这是根据其可能产生的影响或严重程度，而对开发者的提示。FindBugs操作的是Java字节码，而非源代码。软件作为一个独立的图形化应用程序分发。 Eclipse、NetBeans、IntelliJ IDEA、Gradle、Hudson和Jenkins有可用的FindBugs插件。

**项目地址：** https://spotbugs.github.io

## 2.3 单元测试

在「阿里巴巴Java开发手册」中，有专门的一章讲 **单元测试**，请参考该章即可。

## 2.4 代码复读

这是很多公司推的一种人肉保证质量的方式。

# 3. grape插件规范

## 3.1 命名规范

- 每一个插件都有一个名字，即包名，用名词，全部小写，如`data`
- 子包名统一使用：`domain`,`controller`,`service`,`service.impl`等
- 包下面有一个插件类文件，命名格式为插件名+Plugin，如：`DataPlugin`
- domain中，表名统一使用 `插件名 + domain名`，如`DATA_PARAMETER`

## 3.2 SQL规范

- 尽可能的使用Ebean构造SQL，不要自己手工写
- 如果有自己写的SQL，请保证至少支持5种数据库：MySQL、Oracle、Postgresql、SQL Server、DB2

## 3.3 模块间调用

- 模块间使用dubbo作为RPC调用
- 在生产者一侧，使用Service注解
- 在消费者一侧，使用Reference(check=false)注解

# 4. 前后台接口规范

前后台接口建议采用 **swagger** 定义，不建议使用接口文档。

swagger已经成为前后台接口的标准。

## 4.1 swagger

Swagger是一个开源软件框架，由大型工具生态系统支持，可帮助开发人员设计，构建，记录和使用RESTful Web服务。大多数用户通过Swagger UI工具识别Swagger，但Swagger工具集支持自动文档，代码生成和测试用例生成。

## 4.2 RESTful API规范

该模范非强制，但非常具有参考意义。

**RESTful API 设计指南：**http://www.ruanyifeng.com/blog/2014/05/restful_api.html

# 5. 打包与版本规范

## 5.1 版本

- 交付客户 或 部署到生产环境的，必须为正式版，不能为SNAPSHOT开发版
- 正式版要求饶有的jar包都要用正式的版本号
- 版本号由点分隔的3位组成，即x.y.z，其中x为大版本，y为小版本，z为修复Bug版本
- 一个正式版发布后，不允许改动，一个版本只会对应一份源码
- 每个版本对应的源码，都必须在git仓库上打tag，根据tag找到的源码必须与实际发布的应用包一致

## 5.2 打包

- 正式版打包必须用maven的release插件
- 打包过程中建好的tag必须推到远程仓库，且不允许删除

## 5.3 分支

- 分支有2类：master 和 release类
- master：开发所有的commit只push到master
- release：用于修改bug，从master上cherry-pick修复bug的commit到release分支